// Generated by CoffeeScript 1.6.3
(function() {
  var async, fs, path, utils, _;

  fs = require('fs');

  async = require('async');

  _ = require('underscore');

  utils = require('./utils');

  path = require('path');

  module.exports = function(logger, fnCompile, inputDir, inputSuffix, outputDir, outputSuffix, cb) {
    return async.parallel([
      function(cbFindInput) {
        return utils.findFiles(inputDir, function(inputPath) {
          return utils.stringEndsWidth(inputPath, inputSuffix);
        }, cbFindInput);
      }, function(cbFindOutput) {
        return utils.findFiles(outputDir, function(outputPath) {
          return utils.stringEndsWidth(outputPath, outputSuffix);
        }, cbFindOutput);
      }
    ], function(err, files) {
      var allFilesToCompile, allOutputDirs, filesOk, filesToCompile, inputFiles, outputFiles;
      if (err) {
        return cb(new Error("Error scanning files: " + err));
      }
      inputFiles = files[0], outputFiles = files[1];
      filesToCompile = {
        outOfDate: [],
        newFiles: []
      };
      filesOk = [];
      _.each(inputFiles, function(fileStat, filepath) {
        var outputOfInputFile;
        outputOfInputFile = outputDir + filepath.slice(inputDir.length).slice(0, -inputSuffix.length) + outputSuffix;
        if (!outputFiles[outputOfInputFile]) {
          return filesToCompile.newFiles.push({
            input: filepath,
            output: outputOfInputFile
          });
        } else if (outputFiles[outputOfInputFile].mtime.getTime() < fileStat.mtime.getTime()) {
          return filesToCompile.outOfDate.push({
            input: filepath,
            output: outputOfInputFile
          });
        } else {
          return filesOk.push(filepath);
        }
      });
      logger.info("" + inputSuffix + ": " + filesToCompile.outOfDate.length + " files out of date, " + filesToCompile.newFiles.length + " new files, " + filesOk.length + " files unchanged");
      allFilesToCompile = filesToCompile.outOfDate.concat(filesToCompile.newFiles);
      allOutputDirs = _.uniq(_.map(allFilesToCompile, function(fileInfo) {
        return fileInfo.output.slice(0, _.lastIndexOf(fileInfo.output, path.sep));
      }));
      if (allOutputDirs.length > 0) {
        return async.map(allOutputDirs, function(dir, cbMkDir) {
          return utils.mkdirs(dir, cbMkDir);
        }, function(err) {
          if (err && err.code !== 'EEXIST') {
            return cb(err);
          }
          if (allFilesToCompile.length > 0) {
            return async.map(allFilesToCompile, function(fileInfo, cbCompileFile) {
              logger.trace("Compiling " + fileInfo.input);
              return async.waterfall([
                function(cbRead) {
                  return fs.readFile(fileInfo.input, 'utf8', cbRead);
                }, function(code, cbCompile) {
                  return fnCompile(code, cbCompile);
                }, function(compiled, cbWrite) {
                  return fs.writeFile(fileInfo.output, compiled, 'utf8', cbWrite);
                }
              ], function(err) {
                if (err) {
                  return cbCompileFile(new Error("Error compiling '" + fileInfo.input + "': " + err));
                }
                return cbCompileFile(null);
              });
            }, cb);
          }
        });
      } else {
        return cb(null);
      }
    });
  };

}).call(this);
